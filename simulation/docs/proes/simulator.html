<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>proes.simulator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>proes.simulator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from shells import Shell, Emitter
import numpy as np
import matplotlib.pyplot as plt
import math
from astropy.cosmology import Planck18
import config
import os.path as path
from os.path import exists
# import sys
#
# path = path.dirname(path.abspath(__file__))
# sys.path.append(path)

c = 3e+5

class Simulator():
    &#34;&#34;&#34;
    A class to create a simulation of the GRB prompt emission.

    --------------------------------------------------------------------------------
                                Parameters contained:
    --------------------------------------------------------------------------------
    emitter:        an Emitter object to represent the central engine of the GRB.

    sim_time:       a list containing the timesteps within the simulation

    obs_time:       a list containing the time of shell collisions from an observer on Earth&#39;s frame of reference

    t_obs:          a list containing the time of shell collisions from an observer on Earth&#39;s frame of reference,
                    corrected for a time delay offset

    --------------------------------------------------------------------------------
    &#34;&#34;&#34;
    def __init__(self, emitter):
        &#34;&#34;&#34;
        Initialises the simulation

        Parameters:
            emitter:        an Emitter object to represent the central engine of the GRB.
        &#34;&#34;&#34;
        self.emitter = emitter
        self.sim_time = [0]
        self.obs_time = []
        self.t_obs = []

        if config.ENABLE_LOGGING:
            if (os.path.exists(path.join(config.LOG_PATH, &#39;collision.log&#39;))):
                os.remove(path.join(config.LOG_PATH, &#39;collision.log&#39;))
                f = open(path.join(config.LOG_PATH, &#39;collision.log&#39;), &#39;x&#39;)
                f.close()
            if (os.path.exists(path.join(config.LOG_PATH,&#39;photons.log&#39;))):
                os.remove(path.join(config.LOG_PATH,&#39;photons.log&#39;))
                f = open(path.join(config.LOG_PATH,&#39;photons.log&#39;), &#39;x&#39;)
                f.close()

            if (os.path.exists(path.join(config.LOG_PATH, &#39;protons.log&#39;))):
                os.remove(path.join(config.LOG_PATH, &#39;protons.log&#39;))
                f = open(path.join(config.LOG_PATH, &#39;protons.log&#39;), &#39;x&#39;)
                f.close()

    def sim_emitter_setup(self, gamma1, gamma2, tp, dist):
        &#34;&#34;&#34;
        Sets up the central engine of the burst, and sets up the shells emitted by the central engine - assigning indices, Lorentz factors, widths, and distances from central engine.

        Parameters:
            gamma1 (float): first characteristic Lorentz factor value

            gamma2 (float): second characteristic Lorentz factor value

            tp (float):     fraction of total emitted shells

            dist (int):     type of Lorentz factor distribution for shells. Possible inputs are
                            1 - profile for GRB1 of Bustamante et al. (2017) (DEFAULT DISTRIBUTION)
                            3 - profile for GRB3 of Bustamante et al. (2017)

        Returns:
            none
        &#34;&#34;&#34;
        self.emitter.setup(gamma1, gamma2, tp, dist)

    def sim_start(self):
        &#34;&#34;&#34;
        Starts the simulation. Each timestep is one shell collision. Within each timestep, the properties of the other shells in the central engine are updated (distance, volume, and density). Shell collisions result in a merged shell, which then propagates with the rest of the shells and may undergo subsequent collisions. The simulation ends if one of three conditions arise as is employed in Bustamante et al. (2017):

        * The shells of matter reach the circumbust medium. This signifies the end of the prompt emission phase as they shock into the interstellar medium (ISM) and produce the afterglow seen in all wavelengths.

        * The shells of matter have all merged into one large remaining shell. This means that no more collisions can occur, and signifies the end of the prompt emission phase.

        * The shells of matter are arranged such that the ordering of their Lorentz factors does not allow for any further collisions. Since fast shells cannot collide with slower shells, internal shocks can no longer occur, which signifies the end of the prompt emission phase due to lack of gamma-ray production.

        Output parameters from the simulation can be accessed via the plotting functions located within this class. If logs or console outputs are needed, these can be turned on or off in the config.py file under the ENABLE_LOGGING and VERBOSE variables respectively.

        Parameters:
            none

        Returns:
            none
        &#34;&#34;&#34;
        st = 0

        while((self.emitter.nshells &gt; 1) and (self.emitter.done == False)):

            # update simulation time to time of next collision
            st += self.emitter.next_collision_time

            # store simulation time
            self.sim_time.append(st)

            # update all shells in simulation
            for shell in self.emitter.shells:
                shell.update_shell(self.emitter.next_collision_time)

            # compute light travel time
            ltt = (Planck18.lookback_distance(self.emitter.z).to_value() * 3.08568e+24 / 3e+10) / (60 * 60 * 24 * 365)

            # compute observed time
            ot = (1 + self.emitter.z)*((((ltt * c) - self.emitter.collision_shells[0].radius) / c) + st)

            # let the emitter know what the simulation time is
            self.emitter.update_tobs(st)

            if config.VERBOSE:
                print(&#34;###############################################&#34;)
                print(&#34;                 SIM INFO&#34;)
                print(&#34;###############################################&#34;)
                print(f&#39;sim time:   {st:.4e}&#39;)
                print(f&#39;obs time:   {ot:.4e}&#39;)
                print(f&#39;nshells:    {self.emitter.nshells}&#39;)
                print(&#34;###############################################&#34;)

            # create a shell collision and store whether or not it is subphotospheric
            res = self.emitter.collision(self.emitter.collision_shells[0], self.emitter.collision_shells[1])

            if (res == 0):
                if config.VERBOSE:
                    print(&#34;Super photospheric collision&#34;)
                self.obs_time.append(ot)
            else:
                if config.VERBOSE:
                    print(&#34;Subphotospheric collision&#34;)

            if config.VERBOSE:
                print(f&#34;collisions occurred: {self.emitter.ncoll}&#34;)

            # calculate next collision time
            self.emitter.calculate_collision_times()

        offset = min(self.obs_time)
        self.t_obs = [i - offset for i in self.obs_time]
        t90 = self.emitter.calculate_t90(self.t_obs)
        tv = self.emitter.calculate_tv(t90)

        if config.VERBOSE:
            print()
            print(&#34;------------------------------------------------------------------&#34;)
            print(&#34;                     OUTPUT PARAMETERS&#34;)
            print(&#34;------------------------------------------------------------------&#34;)
            print(f&#34;Ncoll:           {self.emitter.ncoll}&#34;)
            print(f&#34;tv:              {tv * 1000:.1f} ms&#34;)
            print(f&#34;T90:             {t90:.2f} s&#34;)
            print(f&#34;E_gamma_tot:     {self.emitter.e_gamma_tot:.2e} erg&#34;)
            print()
            print(f&#34;photospheric     {self.emitter.photo}&#34;)
            print(f&#34;sub-photospheric {self.emitter.subphoto}&#34;)
            print(&#34;------------------------------------------------------------------&#34;)

        if config.ENABLE_LOGGING:
            f = open(path.join(config.LOG_PATH, &#39;output.log&#39;), &#39;w&#39;)
            lines = [&#34;------------------------------------------------------------------&#34;, &#34;                     OUTPUT PARAMETERS&#34;, &#34;------------------------------------------------------------------&#34;, f&#34;Ncoll:           {self.emitter.ncoll}&#34;, f&#34;tv:              {tv * 1000:.1f} ms&#34;, f&#34;T90:             {t90:.2f} s&#34;, f&#34;E_gamma_tot:     {self.emitter.e_gamma_tot:.2e} erg&#34;, &#34; &#34;, f&#34;photospheric     {self.emitter.photo}&#34;, f&#34;sub-photospheric {self.emitter.subphoto}&#34;, &#34;------------------------------------------------------------------&#34;, &#34; &#34;]
            f.write(&#39;\n&#39;.join(lines))
            f.close()

    def plot_initial_lorentz_factors(self):
        &#34;&#34;&#34;
        Plots the initial Lorentz factors of the shells within the simulation. This function should be called before the sim_start function as it is dependent on intitial parameters. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

        Parameters:
            none

        Returns:
            none
        &#34;&#34;&#34;
        x, y = self.emitter.retrieve_lorentz_factors()
        x = [i / 1e6 for i in x]

        fig = plt.figure(figsize=(8,6))
        ax = fig.add_subplot(1,1,1)

        ax.scatter(x, y, marker=&#39;.&#39;)
        ax.set_xlabel(r&#39;Initial shell radius $r_{k, 0}$ [$\times 10^6$ km]&#39;,fontsize=16)
        ax.set_ylabel(r&#39;Initial Lorentz factor $\Gamma_{k, 0}$&#39;, fontsize=16)
        ax.set_yscale(&#39;log&#39;)
        ax.set(ylim=[10, 1e4])
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
        plt.savefig(path.join(config.IM_PATH, &#39;initial_lorentz_factor_dist.png&#39;))

    def plot_light_curve(self):
        &#34;&#34;&#34;
        Plots the final prompt emission light curve of the GRB. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

        Parameters:
            none

        Returns:
            none
        &#34;&#34;&#34;
        y = self.emitter.light_curve
        y.append(0)
        self.t_obs.append(0)

        tup = sorted(list(zip(self.t_obs, y)))
        x, y = zip(*tup)

        y2 = [i * 1e+6 for i in y]

        if config.VERBOSE:
            print(f&#34;minimum flux {min(y):.4e} GeV/s/cm2 at time {x[y.index(min(y))]:.2f} s&#34;)
            print(f&#34;maximum flux {max(y):.4e} GeV/s/cm2 at time {x[y.index(max(y))]:.2f} s&#34;)

        fig = plt.figure(figsize=(8,6))
        ax = fig.add_axes((.2,.3,.6,.6))

        ax.plot(x, y)
        ax.set_xlabel(r&#39;t$_{obs}$ [s]&#39;,fontsize=16)
        ax.set_ylabel(r&#39;Flux [GeV s$^{-1}$ cm$^{-2}$]&#39;, fontsize=16)
        ax.set_yscale(&#39;log&#39;)
        # ax.set(xlim=[-0.5, 80])
        # ax.set(ylim=[1e-8, 1e-3])
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)

        ax2=fig.add_axes((.2,.1,.6,.2), sharex=ax)
        ax2.plot(x, y2)
        ax2.set_xlabel(r&#39;t$_{obs}$ [s]&#39;,fontsize=16)
        ax2.set_ylabel(r&#39;Counts [A.U.]&#39;, fontsize=16)
        # ax2.set(xlim=[-0.5, 80])
        # ax.set(ylim=[0, 10000])
        # ax2.set(ylim=[0, 700])
        ax2.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
        ax2.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
        ax2.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
        ax2.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
        plt.savefig(path.join(config.IM_PATH, &#39;light_curve.png&#39;))

    def plot_optical_depth(self):
        &#34;&#34;&#34;
        Plots the optical depth to Thomson scattering for each shell collision at a given collisional radius. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

        Parameters:
            none

        Returns:
            none
        &#34;&#34;&#34;
        x = self.emitter.r_coll
        y = [1/i for i in self.emitter.op_depth]
        # y = self.emitter.op_depth

        fig = plt.figure(figsize=(8,6))
        ax = fig.add_subplot(1,1,1)
        ax.scatter(x, y, marker=&#39;.&#39;)
        ax.set_xlabel(r&#39;$R_{C}$ [km]&#39;,fontsize=16)
        ax.set_ylabel(r&#39;$\tau_{p \gamma}$&#39;, fontsize=16)
        ax.set_xscale(&#39;log&#39;)
        ax.set_yscale(&#39;log&#39;)
        ax.axhline(y=1, linestyle=&#39;--&#39;, color=&#39;k&#39;, linewidth=0.8)
        ax.text(1e+10, 1e+3, &#39;subphotospheric&#39;, fontsize=14)
        ax.fill_between([min(x)-1e+3, max(x)+1e+3], 1, max(y), color=&#39;k&#39;, alpha=0.2)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
        plt.savefig(path.join(config.IM_PATH, &#39;optical_depth.png&#39;))

    def plot_proton_energy_spectrum(self):
        &#34;&#34;&#34;
        Plots the final proton energy spectrum as a result of Fermi acceleration within shell collisions of the burst. Please note that the number densities have been binned for each energy. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

        Parameters:
            none

        Returns:
            none
        &#34;&#34;&#34;
        x = self.emitter.e_prot_n_
        y = self.emitter.e_prot_n

        da = list(zip(x, y))
        bin_x = [1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11]
        bin_y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

        for i in da:
            for j in range(len(i[0])):
                match math.floor(math.log10(i[0][j])):
                    case -5:
                        bin_y[0] += i[1][j]
                    case -4:
                        bin_y[1] += i[1][j]
                    case -3:
                        bin_y[2] += i[1][j]
                    case -2:
                        bin_y[3] += i[1][j]
                    case -1:
                        bin_y[4] += i[1][j]
                    case 0:
                        bin_y[5] += i[1][j]
                    case 1:
                        bin_y[6] += i[1][j]
                    case 2:
                        bin_y[7] += i[1][j]
                    case 3:
                        bin_y[8] += i[1][j]
                    case 4:
                        bin_y[9] += i[1][j]
                    case 5:
                        bin_y[10] += i[1][j]
                    case 6:
                        bin_y[11] += i[1][j]
                    case 7:
                        bin_y[12] += i[1][j]
                    case 8:
                        bin_y[13] += i[1][j]
                    case 9:
                        bin_y[14] += i[1][j]
                    case 10:
                        bin_y[15] += i[1][j]

        bin_y = [bin_y[i] / bin_x[i] for i in range(len(bin_y))]

        fig = plt.figure(figsize=(8,6))
        ax = fig.add_subplot(1,1,1)
        ax.plot(bin_x, bin_y)
        ax.set_xlabel(r&#39;$E_{p}$ [GeV]&#39;,fontsize=16)
        ax.set_ylabel(r&#39;N(E$_{p}$) [GeV]&#39;, fontsize=16)
        ax.set_xscale(&#39;log&#39;)
        ax.set_yscale(&#39;log&#39;)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
        plt.savefig(path.join(config.IM_PATH, &#39;prot_energy_spec.png&#39;))

    def plot_proton_maximum_energy(self):
        &#34;&#34;&#34;
        Plots the initial proton maximum energy for each collision, as well as the refined maximum proton energy taking into account losses as a function of collision radius. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

        Parameters:
            none

        Returns:
            none
        &#34;&#34;&#34;
        x = self.emitter.r_coll
        y = self.emitter.e_prot
        z = self.emitter.e_prot_max

        tup = sorted(list(zip(x, y)))
        x, y = zip(*tup)

        fig = plt.figure(figsize=(8,6))
        ax = fig.add_subplot(1,1,1)
        ax.plot(x, y, label=&#39;with losses&#39;)

        tup = sorted(list(zip(x, z)))
        x, z = zip(*tup)
        ax.plot(x, z, label=&#39;without losses&#39;)
        ax.axhline(1e+9, linestyle=&#39;--&#39;, color=&#39;k&#39;)
        ax.set_xlabel(r&#39;R$_{c}$ [km]&#39;,fontsize=16)
        ax.set_ylabel(r&#39;$E_{p, max}$ [GeV]&#39;, fontsize=16)
        ax.set_xscale(&#39;log&#39;)
        ax.set_yscale(&#39;log&#39;)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
        ax.legend()
        plt.savefig(path.join(config.IM_PATH, &#39;prot_energy_rad_both.png&#39;))

    def plot_proton_energy_loss_timescales(self):
        &#34;&#34;&#34;
        Plots the proton energy loss timescales for each shell collision as a function of collision radius. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

        Parameters:
            none

        Returns:
            none
        &#34;&#34;&#34;
        x = self.emitter.r_coll
        y = self.emitter.t_syn
        z = self.emitter.t_dyn

        tup = sorted(list(zip(x, y)))
        x, y = zip(*tup)

        fig = plt.figure(figsize=(8,6))
        ax = fig.add_subplot(1,1,1)
        ax.plot(x, y, label=&#39;synchrotron losses timescale&#39;)

        tup = sorted(list(zip(x, z)))
        x, z = zip(*tup)
        ax.plot(x, z, label=&#39;dynamical loss timescale&#39;)
        ax.set_xlabel(r&#39;R$_{c}$ [km]&#39;,fontsize=16)
        ax.set_ylabel(r&#39;t$^{-1}$ [s$^{-1}$]&#39;, fontsize=16)
        ax.set_xscale(&#39;log&#39;)
        ax.set_yscale(&#39;log&#39;)

        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
        ax.legend()
        plt.savefig(path.join(config.IM_PATH, &#39;loss_timescales.png&#39;))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="proes.simulator.Simulator"><code class="flex name class">
<span>class <span class="ident">Simulator</span></span>
<span>(</span><span>emitter)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to create a simulation of the GRB prompt emission.</p>
<hr>
<pre><code>                        Parameters contained:
</code></pre>
<hr>
<p>emitter:
an Emitter object to represent the central engine of the GRB.</p>
<p>sim_time:
a list containing the timesteps within the simulation</p>
<p>obs_time:
a list containing the time of shell collisions from an observer on Earth's frame of reference</p>
<p>t_obs:
a list containing the time of shell collisions from an observer on Earth's frame of reference,
corrected for a time delay offset</p>
<hr>
<p>Initialises the simulation</p>
<h2 id="parameters">Parameters</h2>
<p>emitter:
an Emitter object to represent the central engine of the GRB.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Simulator():
    &#34;&#34;&#34;
    A class to create a simulation of the GRB prompt emission.

    --------------------------------------------------------------------------------
                                Parameters contained:
    --------------------------------------------------------------------------------
    emitter:        an Emitter object to represent the central engine of the GRB.

    sim_time:       a list containing the timesteps within the simulation

    obs_time:       a list containing the time of shell collisions from an observer on Earth&#39;s frame of reference

    t_obs:          a list containing the time of shell collisions from an observer on Earth&#39;s frame of reference,
                    corrected for a time delay offset

    --------------------------------------------------------------------------------
    &#34;&#34;&#34;
    def __init__(self, emitter):
        &#34;&#34;&#34;
        Initialises the simulation

        Parameters:
            emitter:        an Emitter object to represent the central engine of the GRB.
        &#34;&#34;&#34;
        self.emitter = emitter
        self.sim_time = [0]
        self.obs_time = []
        self.t_obs = []

        if config.ENABLE_LOGGING:
            if (os.path.exists(path.join(config.LOG_PATH, &#39;collision.log&#39;))):
                os.remove(path.join(config.LOG_PATH, &#39;collision.log&#39;))
                f = open(path.join(config.LOG_PATH, &#39;collision.log&#39;), &#39;x&#39;)
                f.close()
            if (os.path.exists(path.join(config.LOG_PATH,&#39;photons.log&#39;))):
                os.remove(path.join(config.LOG_PATH,&#39;photons.log&#39;))
                f = open(path.join(config.LOG_PATH,&#39;photons.log&#39;), &#39;x&#39;)
                f.close()

            if (os.path.exists(path.join(config.LOG_PATH, &#39;protons.log&#39;))):
                os.remove(path.join(config.LOG_PATH, &#39;protons.log&#39;))
                f = open(path.join(config.LOG_PATH, &#39;protons.log&#39;), &#39;x&#39;)
                f.close()

    def sim_emitter_setup(self, gamma1, gamma2, tp, dist):
        &#34;&#34;&#34;
        Sets up the central engine of the burst, and sets up the shells emitted by the central engine - assigning indices, Lorentz factors, widths, and distances from central engine.

        Parameters:
            gamma1 (float): first characteristic Lorentz factor value

            gamma2 (float): second characteristic Lorentz factor value

            tp (float):     fraction of total emitted shells

            dist (int):     type of Lorentz factor distribution for shells. Possible inputs are
                            1 - profile for GRB1 of Bustamante et al. (2017) (DEFAULT DISTRIBUTION)
                            3 - profile for GRB3 of Bustamante et al. (2017)

        Returns:
            none
        &#34;&#34;&#34;
        self.emitter.setup(gamma1, gamma2, tp, dist)

    def sim_start(self):
        &#34;&#34;&#34;
        Starts the simulation. Each timestep is one shell collision. Within each timestep, the properties of the other shells in the central engine are updated (distance, volume, and density). Shell collisions result in a merged shell, which then propagates with the rest of the shells and may undergo subsequent collisions. The simulation ends if one of three conditions arise as is employed in Bustamante et al. (2017):

        * The shells of matter reach the circumbust medium. This signifies the end of the prompt emission phase as they shock into the interstellar medium (ISM) and produce the afterglow seen in all wavelengths.

        * The shells of matter have all merged into one large remaining shell. This means that no more collisions can occur, and signifies the end of the prompt emission phase.

        * The shells of matter are arranged such that the ordering of their Lorentz factors does not allow for any further collisions. Since fast shells cannot collide with slower shells, internal shocks can no longer occur, which signifies the end of the prompt emission phase due to lack of gamma-ray production.

        Output parameters from the simulation can be accessed via the plotting functions located within this class. If logs or console outputs are needed, these can be turned on or off in the config.py file under the ENABLE_LOGGING and VERBOSE variables respectively.

        Parameters:
            none

        Returns:
            none
        &#34;&#34;&#34;
        st = 0

        while((self.emitter.nshells &gt; 1) and (self.emitter.done == False)):

            # update simulation time to time of next collision
            st += self.emitter.next_collision_time

            # store simulation time
            self.sim_time.append(st)

            # update all shells in simulation
            for shell in self.emitter.shells:
                shell.update_shell(self.emitter.next_collision_time)

            # compute light travel time
            ltt = (Planck18.lookback_distance(self.emitter.z).to_value() * 3.08568e+24 / 3e+10) / (60 * 60 * 24 * 365)

            # compute observed time
            ot = (1 + self.emitter.z)*((((ltt * c) - self.emitter.collision_shells[0].radius) / c) + st)

            # let the emitter know what the simulation time is
            self.emitter.update_tobs(st)

            if config.VERBOSE:
                print(&#34;###############################################&#34;)
                print(&#34;                 SIM INFO&#34;)
                print(&#34;###############################################&#34;)
                print(f&#39;sim time:   {st:.4e}&#39;)
                print(f&#39;obs time:   {ot:.4e}&#39;)
                print(f&#39;nshells:    {self.emitter.nshells}&#39;)
                print(&#34;###############################################&#34;)

            # create a shell collision and store whether or not it is subphotospheric
            res = self.emitter.collision(self.emitter.collision_shells[0], self.emitter.collision_shells[1])

            if (res == 0):
                if config.VERBOSE:
                    print(&#34;Super photospheric collision&#34;)
                self.obs_time.append(ot)
            else:
                if config.VERBOSE:
                    print(&#34;Subphotospheric collision&#34;)

            if config.VERBOSE:
                print(f&#34;collisions occurred: {self.emitter.ncoll}&#34;)

            # calculate next collision time
            self.emitter.calculate_collision_times()

        offset = min(self.obs_time)
        self.t_obs = [i - offset for i in self.obs_time]
        t90 = self.emitter.calculate_t90(self.t_obs)
        tv = self.emitter.calculate_tv(t90)

        if config.VERBOSE:
            print()
            print(&#34;------------------------------------------------------------------&#34;)
            print(&#34;                     OUTPUT PARAMETERS&#34;)
            print(&#34;------------------------------------------------------------------&#34;)
            print(f&#34;Ncoll:           {self.emitter.ncoll}&#34;)
            print(f&#34;tv:              {tv * 1000:.1f} ms&#34;)
            print(f&#34;T90:             {t90:.2f} s&#34;)
            print(f&#34;E_gamma_tot:     {self.emitter.e_gamma_tot:.2e} erg&#34;)
            print()
            print(f&#34;photospheric     {self.emitter.photo}&#34;)
            print(f&#34;sub-photospheric {self.emitter.subphoto}&#34;)
            print(&#34;------------------------------------------------------------------&#34;)

        if config.ENABLE_LOGGING:
            f = open(path.join(config.LOG_PATH, &#39;output.log&#39;), &#39;w&#39;)
            lines = [&#34;------------------------------------------------------------------&#34;, &#34;                     OUTPUT PARAMETERS&#34;, &#34;------------------------------------------------------------------&#34;, f&#34;Ncoll:           {self.emitter.ncoll}&#34;, f&#34;tv:              {tv * 1000:.1f} ms&#34;, f&#34;T90:             {t90:.2f} s&#34;, f&#34;E_gamma_tot:     {self.emitter.e_gamma_tot:.2e} erg&#34;, &#34; &#34;, f&#34;photospheric     {self.emitter.photo}&#34;, f&#34;sub-photospheric {self.emitter.subphoto}&#34;, &#34;------------------------------------------------------------------&#34;, &#34; &#34;]
            f.write(&#39;\n&#39;.join(lines))
            f.close()

    def plot_initial_lorentz_factors(self):
        &#34;&#34;&#34;
        Plots the initial Lorentz factors of the shells within the simulation. This function should be called before the sim_start function as it is dependent on intitial parameters. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

        Parameters:
            none

        Returns:
            none
        &#34;&#34;&#34;
        x, y = self.emitter.retrieve_lorentz_factors()
        x = [i / 1e6 for i in x]

        fig = plt.figure(figsize=(8,6))
        ax = fig.add_subplot(1,1,1)

        ax.scatter(x, y, marker=&#39;.&#39;)
        ax.set_xlabel(r&#39;Initial shell radius $r_{k, 0}$ [$\times 10^6$ km]&#39;,fontsize=16)
        ax.set_ylabel(r&#39;Initial Lorentz factor $\Gamma_{k, 0}$&#39;, fontsize=16)
        ax.set_yscale(&#39;log&#39;)
        ax.set(ylim=[10, 1e4])
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
        plt.savefig(path.join(config.IM_PATH, &#39;initial_lorentz_factor_dist.png&#39;))

    def plot_light_curve(self):
        &#34;&#34;&#34;
        Plots the final prompt emission light curve of the GRB. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

        Parameters:
            none

        Returns:
            none
        &#34;&#34;&#34;
        y = self.emitter.light_curve
        y.append(0)
        self.t_obs.append(0)

        tup = sorted(list(zip(self.t_obs, y)))
        x, y = zip(*tup)

        y2 = [i * 1e+6 for i in y]

        if config.VERBOSE:
            print(f&#34;minimum flux {min(y):.4e} GeV/s/cm2 at time {x[y.index(min(y))]:.2f} s&#34;)
            print(f&#34;maximum flux {max(y):.4e} GeV/s/cm2 at time {x[y.index(max(y))]:.2f} s&#34;)

        fig = plt.figure(figsize=(8,6))
        ax = fig.add_axes((.2,.3,.6,.6))

        ax.plot(x, y)
        ax.set_xlabel(r&#39;t$_{obs}$ [s]&#39;,fontsize=16)
        ax.set_ylabel(r&#39;Flux [GeV s$^{-1}$ cm$^{-2}$]&#39;, fontsize=16)
        ax.set_yscale(&#39;log&#39;)
        # ax.set(xlim=[-0.5, 80])
        # ax.set(ylim=[1e-8, 1e-3])
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)

        ax2=fig.add_axes((.2,.1,.6,.2), sharex=ax)
        ax2.plot(x, y2)
        ax2.set_xlabel(r&#39;t$_{obs}$ [s]&#39;,fontsize=16)
        ax2.set_ylabel(r&#39;Counts [A.U.]&#39;, fontsize=16)
        # ax2.set(xlim=[-0.5, 80])
        # ax.set(ylim=[0, 10000])
        # ax2.set(ylim=[0, 700])
        ax2.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
        ax2.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
        ax2.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
        ax2.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
        plt.savefig(path.join(config.IM_PATH, &#39;light_curve.png&#39;))

    def plot_optical_depth(self):
        &#34;&#34;&#34;
        Plots the optical depth to Thomson scattering for each shell collision at a given collisional radius. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

        Parameters:
            none

        Returns:
            none
        &#34;&#34;&#34;
        x = self.emitter.r_coll
        y = [1/i for i in self.emitter.op_depth]
        # y = self.emitter.op_depth

        fig = plt.figure(figsize=(8,6))
        ax = fig.add_subplot(1,1,1)
        ax.scatter(x, y, marker=&#39;.&#39;)
        ax.set_xlabel(r&#39;$R_{C}$ [km]&#39;,fontsize=16)
        ax.set_ylabel(r&#39;$\tau_{p \gamma}$&#39;, fontsize=16)
        ax.set_xscale(&#39;log&#39;)
        ax.set_yscale(&#39;log&#39;)
        ax.axhline(y=1, linestyle=&#39;--&#39;, color=&#39;k&#39;, linewidth=0.8)
        ax.text(1e+10, 1e+3, &#39;subphotospheric&#39;, fontsize=14)
        ax.fill_between([min(x)-1e+3, max(x)+1e+3], 1, max(y), color=&#39;k&#39;, alpha=0.2)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
        plt.savefig(path.join(config.IM_PATH, &#39;optical_depth.png&#39;))

    def plot_proton_energy_spectrum(self):
        &#34;&#34;&#34;
        Plots the final proton energy spectrum as a result of Fermi acceleration within shell collisions of the burst. Please note that the number densities have been binned for each energy. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

        Parameters:
            none

        Returns:
            none
        &#34;&#34;&#34;
        x = self.emitter.e_prot_n_
        y = self.emitter.e_prot_n

        da = list(zip(x, y))
        bin_x = [1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11]
        bin_y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

        for i in da:
            for j in range(len(i[0])):
                match math.floor(math.log10(i[0][j])):
                    case -5:
                        bin_y[0] += i[1][j]
                    case -4:
                        bin_y[1] += i[1][j]
                    case -3:
                        bin_y[2] += i[1][j]
                    case -2:
                        bin_y[3] += i[1][j]
                    case -1:
                        bin_y[4] += i[1][j]
                    case 0:
                        bin_y[5] += i[1][j]
                    case 1:
                        bin_y[6] += i[1][j]
                    case 2:
                        bin_y[7] += i[1][j]
                    case 3:
                        bin_y[8] += i[1][j]
                    case 4:
                        bin_y[9] += i[1][j]
                    case 5:
                        bin_y[10] += i[1][j]
                    case 6:
                        bin_y[11] += i[1][j]
                    case 7:
                        bin_y[12] += i[1][j]
                    case 8:
                        bin_y[13] += i[1][j]
                    case 9:
                        bin_y[14] += i[1][j]
                    case 10:
                        bin_y[15] += i[1][j]

        bin_y = [bin_y[i] / bin_x[i] for i in range(len(bin_y))]

        fig = plt.figure(figsize=(8,6))
        ax = fig.add_subplot(1,1,1)
        ax.plot(bin_x, bin_y)
        ax.set_xlabel(r&#39;$E_{p}$ [GeV]&#39;,fontsize=16)
        ax.set_ylabel(r&#39;N(E$_{p}$) [GeV]&#39;, fontsize=16)
        ax.set_xscale(&#39;log&#39;)
        ax.set_yscale(&#39;log&#39;)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
        plt.savefig(path.join(config.IM_PATH, &#39;prot_energy_spec.png&#39;))

    def plot_proton_maximum_energy(self):
        &#34;&#34;&#34;
        Plots the initial proton maximum energy for each collision, as well as the refined maximum proton energy taking into account losses as a function of collision radius. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

        Parameters:
            none

        Returns:
            none
        &#34;&#34;&#34;
        x = self.emitter.r_coll
        y = self.emitter.e_prot
        z = self.emitter.e_prot_max

        tup = sorted(list(zip(x, y)))
        x, y = zip(*tup)

        fig = plt.figure(figsize=(8,6))
        ax = fig.add_subplot(1,1,1)
        ax.plot(x, y, label=&#39;with losses&#39;)

        tup = sorted(list(zip(x, z)))
        x, z = zip(*tup)
        ax.plot(x, z, label=&#39;without losses&#39;)
        ax.axhline(1e+9, linestyle=&#39;--&#39;, color=&#39;k&#39;)
        ax.set_xlabel(r&#39;R$_{c}$ [km]&#39;,fontsize=16)
        ax.set_ylabel(r&#39;$E_{p, max}$ [GeV]&#39;, fontsize=16)
        ax.set_xscale(&#39;log&#39;)
        ax.set_yscale(&#39;log&#39;)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
        ax.legend()
        plt.savefig(path.join(config.IM_PATH, &#39;prot_energy_rad_both.png&#39;))

    def plot_proton_energy_loss_timescales(self):
        &#34;&#34;&#34;
        Plots the proton energy loss timescales for each shell collision as a function of collision radius. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

        Parameters:
            none

        Returns:
            none
        &#34;&#34;&#34;
        x = self.emitter.r_coll
        y = self.emitter.t_syn
        z = self.emitter.t_dyn

        tup = sorted(list(zip(x, y)))
        x, y = zip(*tup)

        fig = plt.figure(figsize=(8,6))
        ax = fig.add_subplot(1,1,1)
        ax.plot(x, y, label=&#39;synchrotron losses timescale&#39;)

        tup = sorted(list(zip(x, z)))
        x, z = zip(*tup)
        ax.plot(x, z, label=&#39;dynamical loss timescale&#39;)
        ax.set_xlabel(r&#39;R$_{c}$ [km]&#39;,fontsize=16)
        ax.set_ylabel(r&#39;t$^{-1}$ [s$^{-1}$]&#39;, fontsize=16)
        ax.set_xscale(&#39;log&#39;)
        ax.set_yscale(&#39;log&#39;)

        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
        ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
        ax.legend()
        plt.savefig(path.join(config.IM_PATH, &#39;loss_timescales.png&#39;))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="proes.simulator.Simulator.plot_initial_lorentz_factors"><code class="name flex">
<span>def <span class="ident">plot_initial_lorentz_factors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the initial Lorentz factors of the shells within the simulation. This function should be called before the sim_start function as it is dependent on intitial parameters. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.</p>
<h2 id="parameters">Parameters</h2>
<p>none</p>
<h2 id="returns">Returns</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_initial_lorentz_factors(self):
    &#34;&#34;&#34;
    Plots the initial Lorentz factors of the shells within the simulation. This function should be called before the sim_start function as it is dependent on intitial parameters. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

    Parameters:
        none

    Returns:
        none
    &#34;&#34;&#34;
    x, y = self.emitter.retrieve_lorentz_factors()
    x = [i / 1e6 for i in x]

    fig = plt.figure(figsize=(8,6))
    ax = fig.add_subplot(1,1,1)

    ax.scatter(x, y, marker=&#39;.&#39;)
    ax.set_xlabel(r&#39;Initial shell radius $r_{k, 0}$ [$\times 10^6$ km]&#39;,fontsize=16)
    ax.set_ylabel(r&#39;Initial Lorentz factor $\Gamma_{k, 0}$&#39;, fontsize=16)
    ax.set_yscale(&#39;log&#39;)
    ax.set(ylim=[10, 1e4])
    ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
    plt.savefig(path.join(config.IM_PATH, &#39;initial_lorentz_factor_dist.png&#39;))</code></pre>
</details>
</dd>
<dt id="proes.simulator.Simulator.plot_light_curve"><code class="name flex">
<span>def <span class="ident">plot_light_curve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the final prompt emission light curve of the GRB. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.</p>
<h2 id="parameters">Parameters</h2>
<p>none</p>
<h2 id="returns">Returns</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_light_curve(self):
    &#34;&#34;&#34;
    Plots the final prompt emission light curve of the GRB. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

    Parameters:
        none

    Returns:
        none
    &#34;&#34;&#34;
    y = self.emitter.light_curve
    y.append(0)
    self.t_obs.append(0)

    tup = sorted(list(zip(self.t_obs, y)))
    x, y = zip(*tup)

    y2 = [i * 1e+6 for i in y]

    if config.VERBOSE:
        print(f&#34;minimum flux {min(y):.4e} GeV/s/cm2 at time {x[y.index(min(y))]:.2f} s&#34;)
        print(f&#34;maximum flux {max(y):.4e} GeV/s/cm2 at time {x[y.index(max(y))]:.2f} s&#34;)

    fig = plt.figure(figsize=(8,6))
    ax = fig.add_axes((.2,.3,.6,.6))

    ax.plot(x, y)
    ax.set_xlabel(r&#39;t$_{obs}$ [s]&#39;,fontsize=16)
    ax.set_ylabel(r&#39;Flux [GeV s$^{-1}$ cm$^{-2}$]&#39;, fontsize=16)
    ax.set_yscale(&#39;log&#39;)
    # ax.set(xlim=[-0.5, 80])
    # ax.set(ylim=[1e-8, 1e-3])
    ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)

    ax2=fig.add_axes((.2,.1,.6,.2), sharex=ax)
    ax2.plot(x, y2)
    ax2.set_xlabel(r&#39;t$_{obs}$ [s]&#39;,fontsize=16)
    ax2.set_ylabel(r&#39;Counts [A.U.]&#39;, fontsize=16)
    # ax2.set(xlim=[-0.5, 80])
    # ax.set(ylim=[0, 10000])
    # ax2.set(ylim=[0, 700])
    ax2.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
    ax2.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
    ax2.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
    ax2.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
    plt.savefig(path.join(config.IM_PATH, &#39;light_curve.png&#39;))</code></pre>
</details>
</dd>
<dt id="proes.simulator.Simulator.plot_optical_depth"><code class="name flex">
<span>def <span class="ident">plot_optical_depth</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the optical depth to Thomson scattering for each shell collision at a given collisional radius. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.</p>
<h2 id="parameters">Parameters</h2>
<p>none</p>
<h2 id="returns">Returns</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_optical_depth(self):
    &#34;&#34;&#34;
    Plots the optical depth to Thomson scattering for each shell collision at a given collisional radius. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

    Parameters:
        none

    Returns:
        none
    &#34;&#34;&#34;
    x = self.emitter.r_coll
    y = [1/i for i in self.emitter.op_depth]
    # y = self.emitter.op_depth

    fig = plt.figure(figsize=(8,6))
    ax = fig.add_subplot(1,1,1)
    ax.scatter(x, y, marker=&#39;.&#39;)
    ax.set_xlabel(r&#39;$R_{C}$ [km]&#39;,fontsize=16)
    ax.set_ylabel(r&#39;$\tau_{p \gamma}$&#39;, fontsize=16)
    ax.set_xscale(&#39;log&#39;)
    ax.set_yscale(&#39;log&#39;)
    ax.axhline(y=1, linestyle=&#39;--&#39;, color=&#39;k&#39;, linewidth=0.8)
    ax.text(1e+10, 1e+3, &#39;subphotospheric&#39;, fontsize=14)
    ax.fill_between([min(x)-1e+3, max(x)+1e+3], 1, max(y), color=&#39;k&#39;, alpha=0.2)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
    plt.savefig(path.join(config.IM_PATH, &#39;optical_depth.png&#39;))</code></pre>
</details>
</dd>
<dt id="proes.simulator.Simulator.plot_proton_energy_loss_timescales"><code class="name flex">
<span>def <span class="ident">plot_proton_energy_loss_timescales</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the proton energy loss timescales for each shell collision as a function of collision radius. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.</p>
<h2 id="parameters">Parameters</h2>
<p>none</p>
<h2 id="returns">Returns</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_proton_energy_loss_timescales(self):
    &#34;&#34;&#34;
    Plots the proton energy loss timescales for each shell collision as a function of collision radius. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

    Parameters:
        none

    Returns:
        none
    &#34;&#34;&#34;
    x = self.emitter.r_coll
    y = self.emitter.t_syn
    z = self.emitter.t_dyn

    tup = sorted(list(zip(x, y)))
    x, y = zip(*tup)

    fig = plt.figure(figsize=(8,6))
    ax = fig.add_subplot(1,1,1)
    ax.plot(x, y, label=&#39;synchrotron losses timescale&#39;)

    tup = sorted(list(zip(x, z)))
    x, z = zip(*tup)
    ax.plot(x, z, label=&#39;dynamical loss timescale&#39;)
    ax.set_xlabel(r&#39;R$_{c}$ [km]&#39;,fontsize=16)
    ax.set_ylabel(r&#39;t$^{-1}$ [s$^{-1}$]&#39;, fontsize=16)
    ax.set_xscale(&#39;log&#39;)
    ax.set_yscale(&#39;log&#39;)

    ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
    ax.legend()
    plt.savefig(path.join(config.IM_PATH, &#39;loss_timescales.png&#39;))</code></pre>
</details>
</dd>
<dt id="proes.simulator.Simulator.plot_proton_energy_spectrum"><code class="name flex">
<span>def <span class="ident">plot_proton_energy_spectrum</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the final proton energy spectrum as a result of Fermi acceleration within shell collisions of the burst. Please note that the number densities have been binned for each energy. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.</p>
<h2 id="parameters">Parameters</h2>
<p>none</p>
<h2 id="returns">Returns</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_proton_energy_spectrum(self):
    &#34;&#34;&#34;
    Plots the final proton energy spectrum as a result of Fermi acceleration within shell collisions of the burst. Please note that the number densities have been binned for each energy. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

    Parameters:
        none

    Returns:
        none
    &#34;&#34;&#34;
    x = self.emitter.e_prot_n_
    y = self.emitter.e_prot_n

    da = list(zip(x, y))
    bin_x = [1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11]
    bin_y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

    for i in da:
        for j in range(len(i[0])):
            match math.floor(math.log10(i[0][j])):
                case -5:
                    bin_y[0] += i[1][j]
                case -4:
                    bin_y[1] += i[1][j]
                case -3:
                    bin_y[2] += i[1][j]
                case -2:
                    bin_y[3] += i[1][j]
                case -1:
                    bin_y[4] += i[1][j]
                case 0:
                    bin_y[5] += i[1][j]
                case 1:
                    bin_y[6] += i[1][j]
                case 2:
                    bin_y[7] += i[1][j]
                case 3:
                    bin_y[8] += i[1][j]
                case 4:
                    bin_y[9] += i[1][j]
                case 5:
                    bin_y[10] += i[1][j]
                case 6:
                    bin_y[11] += i[1][j]
                case 7:
                    bin_y[12] += i[1][j]
                case 8:
                    bin_y[13] += i[1][j]
                case 9:
                    bin_y[14] += i[1][j]
                case 10:
                    bin_y[15] += i[1][j]

    bin_y = [bin_y[i] / bin_x[i] for i in range(len(bin_y))]

    fig = plt.figure(figsize=(8,6))
    ax = fig.add_subplot(1,1,1)
    ax.plot(bin_x, bin_y)
    ax.set_xlabel(r&#39;$E_{p}$ [GeV]&#39;,fontsize=16)
    ax.set_ylabel(r&#39;N(E$_{p}$) [GeV]&#39;, fontsize=16)
    ax.set_xscale(&#39;log&#39;)
    ax.set_yscale(&#39;log&#39;)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
    plt.savefig(path.join(config.IM_PATH, &#39;prot_energy_spec.png&#39;))</code></pre>
</details>
</dd>
<dt id="proes.simulator.Simulator.plot_proton_maximum_energy"><code class="name flex">
<span>def <span class="ident">plot_proton_maximum_energy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the initial proton maximum energy for each collision, as well as the refined maximum proton energy taking into account losses as a function of collision radius. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.</p>
<h2 id="parameters">Parameters</h2>
<p>none</p>
<h2 id="returns">Returns</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_proton_maximum_energy(self):
    &#34;&#34;&#34;
    Plots the initial proton maximum energy for each collision, as well as the refined maximum proton energy taking into account losses as a function of collision radius. The image is saved to the da/im directory within the module, but the location can be altered in the config.py file. If you wish for the plot to be displayed in realtime, make sure that matplotlib.pyplot is imported within your code, and then call plt.show() or equivalent.

    Parameters:
        none

    Returns:
        none
    &#34;&#34;&#34;
    x = self.emitter.r_coll
    y = self.emitter.e_prot
    z = self.emitter.e_prot_max

    tup = sorted(list(zip(x, y)))
    x, y = zip(*tup)

    fig = plt.figure(figsize=(8,6))
    ax = fig.add_subplot(1,1,1)
    ax.plot(x, y, label=&#39;with losses&#39;)

    tup = sorted(list(zip(x, z)))
    x, z = zip(*tup)
    ax.plot(x, z, label=&#39;without losses&#39;)
    ax.axhline(1e+9, linestyle=&#39;--&#39;, color=&#39;k&#39;)
    ax.set_xlabel(r&#39;R$_{c}$ [km]&#39;,fontsize=16)
    ax.set_ylabel(r&#39;$E_{p, max}$ [GeV]&#39;, fontsize=16)
    ax.set_xscale(&#39;log&#39;)
    ax.set_yscale(&#39;log&#39;)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, labelsize=16)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;major&#39;, length=5)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;minor&#39;, length=2.5)
    ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,direction=&#39;in&#39;,right=True,top=True)
    ax.legend()
    plt.savefig(path.join(config.IM_PATH, &#39;prot_energy_rad_both.png&#39;))</code></pre>
</details>
</dd>
<dt id="proes.simulator.Simulator.sim_emitter_setup"><code class="name flex">
<span>def <span class="ident">sim_emitter_setup</span></span>(<span>self, gamma1, gamma2, tp, dist)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up the central engine of the burst, and sets up the shells emitted by the central engine - assigning indices, Lorentz factors, widths, and distances from central engine.</p>
<h2 id="parameters">Parameters</h2>
<p>gamma1 (float): first characteristic Lorentz factor value</p>
<p>gamma2 (float): second characteristic Lorentz factor value</p>
<p>tp (float):
fraction of total emitted shells</p>
<p>dist (int):
type of Lorentz factor distribution for shells. Possible inputs are
1 - profile for GRB1 of Bustamante et al. (2017) (DEFAULT DISTRIBUTION)
3 - profile for GRB3 of Bustamante et al. (2017)</p>
<h2 id="returns">Returns</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sim_emitter_setup(self, gamma1, gamma2, tp, dist):
    &#34;&#34;&#34;
    Sets up the central engine of the burst, and sets up the shells emitted by the central engine - assigning indices, Lorentz factors, widths, and distances from central engine.

    Parameters:
        gamma1 (float): first characteristic Lorentz factor value

        gamma2 (float): second characteristic Lorentz factor value

        tp (float):     fraction of total emitted shells

        dist (int):     type of Lorentz factor distribution for shells. Possible inputs are
                        1 - profile for GRB1 of Bustamante et al. (2017) (DEFAULT DISTRIBUTION)
                        3 - profile for GRB3 of Bustamante et al. (2017)

    Returns:
        none
    &#34;&#34;&#34;
    self.emitter.setup(gamma1, gamma2, tp, dist)</code></pre>
</details>
</dd>
<dt id="proes.simulator.Simulator.sim_start"><code class="name flex">
<span>def <span class="ident">sim_start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts the simulation. Each timestep is one shell collision. Within each timestep, the properties of the other shells in the central engine are updated (distance, volume, and density). Shell collisions result in a merged shell, which then propagates with the rest of the shells and may undergo subsequent collisions. The simulation ends if one of three conditions arise as is employed in Bustamante et al. (2017):</p>
<ul>
<li>
<p>The shells of matter reach the circumbust medium. This signifies the end of the prompt emission phase as they shock into the interstellar medium (ISM) and produce the afterglow seen in all wavelengths.</p>
</li>
<li>
<p>The shells of matter have all merged into one large remaining shell. This means that no more collisions can occur, and signifies the end of the prompt emission phase.</p>
</li>
<li>
<p>The shells of matter are arranged such that the ordering of their Lorentz factors does not allow for any further collisions. Since fast shells cannot collide with slower shells, internal shocks can no longer occur, which signifies the end of the prompt emission phase due to lack of gamma-ray production.</p>
</li>
</ul>
<p>Output parameters from the simulation can be accessed via the plotting functions located within this class. If logs or console outputs are needed, these can be turned on or off in the config.py file under the ENABLE_LOGGING and VERBOSE variables respectively.</p>
<h2 id="parameters">Parameters</h2>
<p>none</p>
<h2 id="returns">Returns</h2>
<p>none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sim_start(self):
    &#34;&#34;&#34;
    Starts the simulation. Each timestep is one shell collision. Within each timestep, the properties of the other shells in the central engine are updated (distance, volume, and density). Shell collisions result in a merged shell, which then propagates with the rest of the shells and may undergo subsequent collisions. The simulation ends if one of three conditions arise as is employed in Bustamante et al. (2017):

    * The shells of matter reach the circumbust medium. This signifies the end of the prompt emission phase as they shock into the interstellar medium (ISM) and produce the afterglow seen in all wavelengths.

    * The shells of matter have all merged into one large remaining shell. This means that no more collisions can occur, and signifies the end of the prompt emission phase.

    * The shells of matter are arranged such that the ordering of their Lorentz factors does not allow for any further collisions. Since fast shells cannot collide with slower shells, internal shocks can no longer occur, which signifies the end of the prompt emission phase due to lack of gamma-ray production.

    Output parameters from the simulation can be accessed via the plotting functions located within this class. If logs or console outputs are needed, these can be turned on or off in the config.py file under the ENABLE_LOGGING and VERBOSE variables respectively.

    Parameters:
        none

    Returns:
        none
    &#34;&#34;&#34;
    st = 0

    while((self.emitter.nshells &gt; 1) and (self.emitter.done == False)):

        # update simulation time to time of next collision
        st += self.emitter.next_collision_time

        # store simulation time
        self.sim_time.append(st)

        # update all shells in simulation
        for shell in self.emitter.shells:
            shell.update_shell(self.emitter.next_collision_time)

        # compute light travel time
        ltt = (Planck18.lookback_distance(self.emitter.z).to_value() * 3.08568e+24 / 3e+10) / (60 * 60 * 24 * 365)

        # compute observed time
        ot = (1 + self.emitter.z)*((((ltt * c) - self.emitter.collision_shells[0].radius) / c) + st)

        # let the emitter know what the simulation time is
        self.emitter.update_tobs(st)

        if config.VERBOSE:
            print(&#34;###############################################&#34;)
            print(&#34;                 SIM INFO&#34;)
            print(&#34;###############################################&#34;)
            print(f&#39;sim time:   {st:.4e}&#39;)
            print(f&#39;obs time:   {ot:.4e}&#39;)
            print(f&#39;nshells:    {self.emitter.nshells}&#39;)
            print(&#34;###############################################&#34;)

        # create a shell collision and store whether or not it is subphotospheric
        res = self.emitter.collision(self.emitter.collision_shells[0], self.emitter.collision_shells[1])

        if (res == 0):
            if config.VERBOSE:
                print(&#34;Super photospheric collision&#34;)
            self.obs_time.append(ot)
        else:
            if config.VERBOSE:
                print(&#34;Subphotospheric collision&#34;)

        if config.VERBOSE:
            print(f&#34;collisions occurred: {self.emitter.ncoll}&#34;)

        # calculate next collision time
        self.emitter.calculate_collision_times()

    offset = min(self.obs_time)
    self.t_obs = [i - offset for i in self.obs_time]
    t90 = self.emitter.calculate_t90(self.t_obs)
    tv = self.emitter.calculate_tv(t90)

    if config.VERBOSE:
        print()
        print(&#34;------------------------------------------------------------------&#34;)
        print(&#34;                     OUTPUT PARAMETERS&#34;)
        print(&#34;------------------------------------------------------------------&#34;)
        print(f&#34;Ncoll:           {self.emitter.ncoll}&#34;)
        print(f&#34;tv:              {tv * 1000:.1f} ms&#34;)
        print(f&#34;T90:             {t90:.2f} s&#34;)
        print(f&#34;E_gamma_tot:     {self.emitter.e_gamma_tot:.2e} erg&#34;)
        print()
        print(f&#34;photospheric     {self.emitter.photo}&#34;)
        print(f&#34;sub-photospheric {self.emitter.subphoto}&#34;)
        print(&#34;------------------------------------------------------------------&#34;)

    if config.ENABLE_LOGGING:
        f = open(path.join(config.LOG_PATH, &#39;output.log&#39;), &#39;w&#39;)
        lines = [&#34;------------------------------------------------------------------&#34;, &#34;                     OUTPUT PARAMETERS&#34;, &#34;------------------------------------------------------------------&#34;, f&#34;Ncoll:           {self.emitter.ncoll}&#34;, f&#34;tv:              {tv * 1000:.1f} ms&#34;, f&#34;T90:             {t90:.2f} s&#34;, f&#34;E_gamma_tot:     {self.emitter.e_gamma_tot:.2e} erg&#34;, &#34; &#34;, f&#34;photospheric     {self.emitter.photo}&#34;, f&#34;sub-photospheric {self.emitter.subphoto}&#34;, &#34;------------------------------------------------------------------&#34;, &#34; &#34;]
        f.write(&#39;\n&#39;.join(lines))
        f.close()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="proes" href="index.html">proes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="proes.simulator.Simulator" href="#proes.simulator.Simulator">Simulator</a></code></h4>
<ul class="">
<li><code><a title="proes.simulator.Simulator.plot_initial_lorentz_factors" href="#proes.simulator.Simulator.plot_initial_lorentz_factors">plot_initial_lorentz_factors</a></code></li>
<li><code><a title="proes.simulator.Simulator.plot_light_curve" href="#proes.simulator.Simulator.plot_light_curve">plot_light_curve</a></code></li>
<li><code><a title="proes.simulator.Simulator.plot_optical_depth" href="#proes.simulator.Simulator.plot_optical_depth">plot_optical_depth</a></code></li>
<li><code><a title="proes.simulator.Simulator.plot_proton_energy_loss_timescales" href="#proes.simulator.Simulator.plot_proton_energy_loss_timescales">plot_proton_energy_loss_timescales</a></code></li>
<li><code><a title="proes.simulator.Simulator.plot_proton_energy_spectrum" href="#proes.simulator.Simulator.plot_proton_energy_spectrum">plot_proton_energy_spectrum</a></code></li>
<li><code><a title="proes.simulator.Simulator.plot_proton_maximum_energy" href="#proes.simulator.Simulator.plot_proton_maximum_energy">plot_proton_maximum_energy</a></code></li>
<li><code><a title="proes.simulator.Simulator.sim_emitter_setup" href="#proes.simulator.Simulator.sim_emitter_setup">sim_emitter_setup</a></code></li>
<li><code><a title="proes.simulator.Simulator.sim_start" href="#proes.simulator.Simulator.sim_start">sim_start</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>